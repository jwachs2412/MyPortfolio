//==============
// Scroll Reveal
//==============

.reveal {
  @media (prefers-reduced-motion: no-preference) {
    // Various 'transition-timing-functions' you can try:
    // transition-timing-function: cubic-bezier(0, 0, 0, 1.5);
    // transition-timing-function: cubic-bezier(0.1, 0.7, 0.6, 0.9);
    // transition-timing-function: cubic-bezier(0.1, 0.03, 0.52, 1);
    // transition-timing-function: cubic-bezier(1, 0.885, 0.72, 1);
    // transition-timing-function: linear( 0, 0.01 3.6%, 0.034, 0.074 9.1%, 0.128 11.4%, 0.194 13.4%, 0.271 15%, 0.544 18.3%, 0.66 20.6%, 0.717 22.4%, 0.765 24.6%, 0.808 27.3%, 0.845 30.4%, 0.883 35.1%, 0.916 40.6%, 0.942 47.2%, 0.963 55%, 0.979 64%, 0.991 74.4%, 0.998 86.4%, 1 );
    // transition-timing-function: ease-in;
    transition-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
    transition-property: transform, opacity;
    transition-duration: 1s;
    transform: translate(0, 150px);
    opacity: 0;
    position: relative;
    will-change: transform;
    &.active {
      opacity: 1;
      transform: translate(0);
    }
  }
}

/////////////////////
// Mixins & Classes

// Classes are added for the mixins if you want to use them while writing your HTML.
// But, for the side-by-side reveals, it's better to use @includes in the CSS because it's easier to change the effects after seeing it on the page.

/////////////////////
// Reveal Left
@mixin reveal-left {
  transform: translate(-150px, 0);
}
.reveal-left {
  @include reveal-left;
}

/////////////////////
// Reveal Right
@mixin reveal-right {
  transform: translate(150px, 0);
}
.reveal-right {
  @include reveal-right;
}

/////////////////////
// Flip In

@mixin rotateIn {
  @media (prefers-reduced-motion: no-preference) {
    transform: rotatex(90deg) translate(0, 0);
    transform-origin: 50% 50%;
    transform-style: preserve-3d;
    transition-duration: 0.7s;
    &.active {
      transform: rotatex(0deg);
    }
  }
}

.reveal-rotateIn {
  @include rotateIn;
}

// For rotate to look 3d, it's parent needs a perspective:
// it's on the body for the demo
// body {
//   perspective: 500px;
// }

/////////////////////
// Scale In

@mixin scaleIn {
  @media (prefers-reduced-motion: no-preference) {
    transform: scale(0.9) translate(0, 70px);
    transition: all 1s cubic-bezier(0.5, 0, 0, 1);
    &.active {
      transform: scale(1);
    }
  }
}

.reveal-scaleIn {
  @include scaleIn;
}

/////////////////////
// Fade In

@mixin fadeIn {
  transform: translate(0, 0);
  transition-duration: 0.5s;
  &.active {
    transform: opacity(1);
  }
}

.reveal-fadeIn {
  @include fadeIn;
}

///////////////////////////////////////////////////////////////////
// Maybe you have side-by-side elements and want them staggered in?

@mixin delay($rule, $number, $value) {
  @media (prefers-reduced-motion: no-preference) {
    @for $i from 2 to ($number + 1) {
      &:nth-child(#{$i}) {
        -webkit-#{$rule}-delay: (#{$i * $value});
        #{$rule}-delay: (#{($i - 1) * $value});
      }
    }
  }
}
// Trigger it like this. Could use an 'animation' as well.
// .reveal-parent on the container adds .reveal to all first children
// First number is number of children, second is the delay between
.reveal-parent > * {
  @include delay(transition, 4, 0.2s);
}

///////////////////////////////////////
// Section specific stuff for this demo

// Using @includes for the rotate children demo instead of classes:
.rotate-parent {
  perspective: 500px;
  > * {
    @include rotateIn;
    @include delay(transition, 4, 0.3s);
  }
}

// Secondary animations inside of the 4 boxes scaleIn demo
.columns.scaleIn-parent > * {
  @media (prefers-reduced-motion: no-preference) {
    overflow: hidden;
    > * {
      @include delay(transition, 3, 0.3s);
      transition: all 1s cubic-bezier(0.16, 1, 0.3, 1);
      transform: translate(0, 200px);
      opacity: 0;
      position: relative;
    }
    &.active > * {
      opacity: 1;
      transform: translate(0);
    }
  }
}
